#include <iostream>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <Windows.h>
#include <io.h>
#include <fcntl.h>

//link dll file 
#pragma comment(lib, "ws2_32.lib")

#define BUFFER_SIZE 1024
#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif 


DWORD gcount = 1;
DWORD ecount = 1;
BOOL isResult;
DWORD nBytes;
HANDLE hMutex = INVALID_HANDLE_VALUE;
HANDLE hEvent = INVALID_HANDLE_VALUE;
CRITICAL_SECTION criticalSection;
CONDITION_VARIABLE conditionVariable;

DWORD WINAPI test_function(__in LPVOID lpnum);
DWORD WINAPI func_even(__in LPVOID lpnum);
DWORD WINAPI func_odd(__in LPVOID lpnum);
DWORD WINAPI func1Event(__in LPVOID lpnum);
DWORD WINAPI func2Event(__in LPVOID lpnum);


VOID FileDirectory();
VOID RegistryKey();
VOID MutexServer();
VOID Semaphore();
VOID UnnamedPipe();
VOID NamedPipeServer();
VOID MailslotServer();
VOID FileMappingServer();
VOID CriticalSection();
VOID EventServer();
VOID InterLocked();
VOID ConditionVariable();



int main() {

    //init win socket 2.2
    WSADATA wsaData;
    int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != NO_ERROR) {
        wprintf(L"WSAStartup function failed with error: %d\n", iResult);
        return 1;
    }
   
    MutexServer();
    EventServer();
	return 0;
}

//============================================= File and Directory =======================================================================

VOID FileDirectory() {

    const wchar_t* bufferRead = new wchar_t[BUFFER_SIZE];
    const wchar_t* bufferWrite = new wchar_t[BUFFER_SIZE];

    // test CreateDirectory function
    const wchar_t* directory = L"./xuanquang";
    wprintf(L"%s :%zd\n", directory, sizeof(directory));
    isResult = CreateDirectoryW(directory, NULL);
    if (isResult == FALSE)
        wprintf(L"Error: %d\n", GetLastError());
    std::cout << BOOL(isResult) << "\n";
    const wchar_t* test = L"xuanquang";

    // test CreateFile fucntion
    HANDLE hFile = INVALID_HANDLE_VALUE;
    hFile = CreateFileW(L"./xuanquang/file1.txt", GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("CreateFile function fail: %d\n", GetLastError());
    }
    else
        printf("CreateFile function success!!!\n");

    //test WriteFile function
    memset((void*)bufferWrite, 0, sizeof(bufferWrite));
    bufferWrite = L"test";
    isResult = WriteFile(hFile, bufferWrite, sizeof(bufferWrite), &nBytes, NULL);

    // test ReadFile function
    memset((void*)bufferRead, 0, BUFFER_SIZE);
    isResult = ReadFile(hFile, (void*)bufferRead, BUFFER_SIZE, &nBytes, NULL);
    if (isResult == FALSE)
        printf("Fail ReadFile: %d\n", GetLastError());
    else {
        //_setmode(_fileno(stdout), _O_U16TEXT);
        wprintf(L"%ls\n", bufferRead);
        std::wcout << L"😏😏😏😏" << "\n";
    }

    //close file handle

    CloseHandle(hFile);

    // test CopyFile and CopyFileExW function
    isResult = CopyFile(L"./xuanquang/file1.txt", L"./xuanquang/file2.txt", FALSE);
    if (isResult == FALSE) {
        printf("Fail CopyFile: %d\n", GetLastError());
    }
    else
        printf("CopyFile Success!!\n");

    LPPROGRESS_ROUTINE lpprogress;

    isResult = CopyFileExW(L"./xuanquang/file1.txt",
        L"./xuanquang/file3.txt", NULL, NULL, FALSE, COPY_FILE_FAIL_IF_EXISTS);
    if (isResult == FALSE) {
        printf("Fail CopyFileExW: %d\n", GetLastError());
    }
    else
        printf("CopyFileExW function success!!!\n");

    // test movefile and movefileexw function
    isResult = MoveFile(L"./xuanquang", L"./dir1");
    if (isResult == false) {
        printf("fail movefile: %d\n", GetLastError());
    }
    else
        printf("movefile function success!!!\n");
    isResult = MoveFileExW(L"./dir1", L"./dir2", MOVEFILE_COPY_ALLOWED);
    if (isResult == false) {
        printf("fail movefileexw: %d\n", GetLastError());
    }
    else
        printf("movefileexw function success!!!\n");
}

//============================================= Registry Keys ============================================================================
VOID RegistryKey() {

    // test RegCreateKeyExW and RegSetValueExW
    LONG lStatus;
    HKEY hKey;
    lStatus = RegCreateKeyExW(HKEY_CURRENT_USER, L"Software\\test\\subtest", 0, NULL,
        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS | KEY_WOW64_64KEY, NULL, &hKey, NULL);

    if (lStatus != ERROR_SUCCESS) {
        printf("RegCreateKeyExW fail: %d\n", GetLastError());
    }
    else
        printf("RegCreateKeyExW succes!!!\n");

    const BYTE* data = (const BYTE*)"xuanquang";
    lStatus = RegSetValueExW(hKey, L"xuanquang", 0, REG_EXPAND_SZ, data, sizeof(data));
    if (lStatus != ERROR_SUCCESS)
        printf("Fail RegSetValue: %d\n", GetLastError());
    else
        printf("RegSetValueExW succes!!!\n");

    lStatus = RegSetValueExW(hKey, L"xuanquang", 0, REG_SZ, (const BYTE*)"test value", 10);
    if (lStatus != ERROR_SUCCESS) {
        printf("Fail RegSetValueExW function: %d\n", GetLastError());
    }
    else
        printf("Success RegSetValueExW function!!!\n");
}

//============================================= Process and Thread =======================================================================

VOID ProcessThread() {
    //test CreateProcess function

    HANDLE hProcess = NULL;
    HANDLE hThread = NULL;
    DWORD dwProcessId = 0;
    DWORD dwThreadId = 0;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));
    isResult = CreateProcess(L"C:\\Windows\\System32\\notepad.exe",
        NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);

    if (isResult == FALSE)
        printf("Fail CreateProcess fucntion: %d\n", GetLastError());
    else {
        printf("Success CreateProcess!!!\n");
        printf("New Process ID: %d\n", pi.dwProcessId);
        printf("Thread ID: %d\n", pi.dwThreadId);
        printf("Test GetProcessId function: %d\n", GetProcessId(pi.hProcess));
        printf("Test GetThreadId function: %d\n", GetThreadId(pi.hThread));
    }


    //test CreateThread function
    hThread = CreateThread(NULL, 0, test_function, (LPVOID) & "xuanquang", 0, &dwThreadId);
    if (hThread == NULL)
        printf("Fail CreateThread function: %d\n", GetLastError());
    printf("CreateThread function success!!!\n");
    printf("Thread ID and Handle: %d - %d\n", dwThreadId, hThread);
    WaitForSingleObject(hThread, INFINITE);

    CloseHandle(hProcess);
    CloseHandle(hThread);
}

//================================================= Semephore ============================================================================

VOID Semaphore() {
    //test CreateSemaphoreEx function
    HANDLE hSemaphore = NULL;
    hSemaphore = CreateSemaphoreExA(NULL, 0, 5, "semaphore1", 0, SEMAPHORE_ALL_ACCESS);
    if (hSemaphore == NULL)
        printf("Fail CreateSemaphoreExA function: %d\n", GetLastError());
    printf("CreateSemaphoreExA success!!!\n");
}


//================================================= Mutex ================================================================================

VOID MutexServer() {
    //test CreateMutex function
    hMutex = CreateMutexExW(NULL, L"xuanquang", 0, MUTEX_ALL_ACCESS);
    if (hMutex == NULL)
        printf("Fail CreateMutex function: %d\n", GetLastError());
    printf("Succes CreateMutex!!!\n");
    printf("Hanlde for new mutex: %d\n", hMutex);


    // an example for multiThread using Mutex technique

    HANDLE hThread1 = NULL;
    HANDLE hThread2 = NULL;

    hThread1 = CreateThread(NULL, 0, func_even, NULL, 0, NULL);
    hThread2 = CreateThread(NULL, 0, func_odd, NULL, 0, NULL);
    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    CloseHandle(hThread1);
    CloseHandle(hThread2);
    CloseHandle(hMutex);
}


//================================================= Unnamed Pipe =========================================================================

VOID UnnamedPipe() {
    //test CreatePipe function
    HANDLE hReadPipe = NULL;
    HANDLE hWritePipe = NULL;

    isResult = CreatePipe(&hReadPipe, &hWritePipe, NULL, BUFFER_SIZE);
    if (isResult == FALSE)
        printf("Fail CreatePipe function: %d\n", GetLastError());
    printf("CreatePipe success!!!\n");

    const char* dataPipe = "xuanquang is here test function!!!";
    printf("%d\n", strlen(dataPipe));
    const char* revBufPipe = new char[BUFFER_SIZE];
    DWORD nBytesPipe = 0;
    isResult = WriteFile(hWritePipe, dataPipe, strlen(dataPipe), &nBytesPipe, NULL);
    memset((void*)revBufPipe, 0, BUFFER_SIZE);
    isResult = ReadFile(hReadPipe, (LPVOID)revBufPipe, BUFFER_SIZE, &nBytesPipe, NULL);
    printf("Receive data: %s\n", revBufPipe);

    CloseHandle(hReadPipe);
    CloseHandle(hWritePipe);
}


//================================================= Named Pipe ===========================================================================


VOID NamedPipeServer() {
    //test CreateNamedPipe
    /*
    * step by step:
    * A. Server side:
    *   1. create named pipe
    *   2. ConnectNamedPipe
    *   3. write/ read data from pipe
    *   4. FlushFileBuffers
    *   5. DisConnectNamedPipe
    *   6. CloseHandle
    * B. Client side:
    *   1. CreateFile or CallNamedPipe
    *   2. WriteFile/ReadFile or TransactNamedPipe
    *   3. CloseHandle
    */
    HANDLE hNamedPipe = NULL;
    const char* outBufNamedPipe = new char[BUFFER_SIZE];
    const char* inBufNamedPipe = new char[BUFFER_SIZE];
    hNamedPipe = CreateNamedPipeW(L"\\\\.\\pipe\\medpipe", PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
        PIPE_UNLIMITED_INSTANCES, BUFFER_SIZE, BUFFER_SIZE, 0, NULL);
    if (hNamedPipe == INVALID_HANDLE_VALUE)
        printf("Fail CreateNamedPipe funcition: %d\n", GetLastError());
    else
        printf("CreateNamedPipe success!!! - %d\n", hNamedPipe);
    isResult = ConnectNamedPipe(hNamedPipe, NULL);
    printf("isResult is: %d\n", isResult);
    if (isResult == FALSE)
        printf("Fail ConnectNamedPipe function: %d\n", GetLastError());
    else
        printf("ConnectNamedPipe success!!!\n");

    const char* writeBufNamedPipe = new char[BUFFER_SIZE];
    const char* readbufNamedPipe = new char[BUFFER_SIZE];
    memset((void*)writeBufNamedPipe, 0, BUFFER_SIZE);
    fputs("Please type message: \n", stdout);
    fgets((char*)writeBufNamedPipe, BUFFER_SIZE, stdin);
    isResult = WriteFile(hNamedPipe, writeBufNamedPipe, strlen(writeBufNamedPipe), &nBytes, NULL);
    if (isResult == FALSE)
        printf("Fail write data t pipe: %d\n", GetLastError());
    isResult = FlushFileBuffers(hNamedPipe);
    if (isResult == FALSE)
        printf("Fail flush buffer in named pipe: %d\n", GetLastError());
    memset((void*)readbufNamedPipe, 0, BUFFER_SIZE);
    isResult = ReadFile(hNamedPipe, (LPVOID)readbufNamedPipe, BUFFER_SIZE, &nBytes, NULL);
    if (isResult == FALSE)
        printf("Fail read data t pipe: %d\n", GetLastError());
    else
        printf("Data read from NamedPipe: %s\n", readbufNamedPipe);

    CloseHandle(hNamedPipe);
}

//================================================ Mailslot Server =======================================================================

VOID MailslotServer() {
    //test Mailslot server
    HANDLE hMailslot = INVALID_HANDLE_VALUE;
    const char* readBufMailslot = new char[BUFFER_SIZE];
    const char* writeBufMailslot = new char[BUFFER_SIZE];
    hMailslot = CreateMailslotW(L"\\\\.\\mailslot\\firstMailslot", 0, MAILSLOT_WAIT_FOREVER, NULL);
    if (hMailslot == INVALID_HANDLE_VALUE)
        printf("Fail CreateMailslot function: %d\n", GetLastError());
    else {
        printf("CreateMailslotW function success!!!\n");
        while (true) {

            //read data
            memset((void*)readBufMailslot, 0, BUFFER_SIZE);
            isResult = ReadFile(hMailslot, (LPVOID)readBufMailslot, BUFFER_SIZE, &nBytes, NULL);
            if (isResult == FALSE)
                printf("Fail read data from client mailslot: %d\n", GetLastError());
            else {
                if (!strcmp(readBufMailslot, "quit\n")) {
                    printf("Exit!!!\n");
                    break;
                }
                else
                    printf("Read data from client: %s\n", readBufMailslot);
            }
        }
    }
    CloseHandle(hMailslot);
}


//============================================ File Mapping ==============================================================================

VOID FileMappingServer() {
    HANDLE hFileMapping = INVALID_HANDLE_VALUE;
    PCHAR startAddressMapping;
    const char* writeBufFileMapping = new char[BUFFER_SIZE];
    hFileMapping = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, 1024, L"firstFileMapping");
    if (hFileMapping == INVALID_HANDLE_VALUE)
        printf("Fail CreateFileMapping!!!");
    else {
        startAddressMapping = (PCHAR)MapViewOfFile(hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, 1024);
        memset((void*)writeBufFileMapping, 0, BUFFER_SIZE);
        fputs("Get input: ", stdout);
        fgets((char*)writeBufFileMapping, BUFFER_SIZE, stdin);
        CopyMemory(startAddressMapping, writeBufFileMapping, BUFFER_SIZE);
        isResult = UnmapViewOfFile(startAddressMapping);
        if (isResult == FALSE)
            printf("Fail UnmapViewOfFile: %d\n", GetLastError());
        else {
            printf("UnmapViewOFFile success!!!\n");
        }
    }      
    CloseHandle(hFileMapping);
}


//============================================ Critical Section ==========================================================================

VOID CriticalSection() {

    HANDLE hThread = INVALID_HANDLE_VALUE;
    DWORD lpThreadId;

    hThread = CreateThread(NULL, 0, test_function, NULL, 0, &lpThreadId);
    if (hThread == NULL)
        printf("Fail create new thread: %d\n", GetLastError());
    else {
        InitializeCriticalSection(&criticalSection);
    }
    WaitForSingleObject(hThread, INFINITE);

    DeleteCriticalSection(&criticalSection);
}

//======================================= Event ==========================================================================================

VOID EventServer() {

    hEvent = INVALID_HANDLE_VALUE;
    HANDLE hThread1, hThread2;
    hThread1 = CreateThread(NULL, 0, func1Event, NULL, 0, NULL);
    hThread2 = CreateThread(NULL, 0, func2Event, NULL, 0, NULL);

    hEvent = CreateEventW(NULL, TRUE, FALSE, L"firstEvent");
    if (hEvent == INVALID_HANDLE_VALUE)
        printf("Fail CreateEvent function: %d\n", GetLastError());
    else {
        printf("CreateEvent success!!!\n");
    }
    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    CloseHandle(hThread1);
    CloseHandle(hThread2);
    CloseHandle(hEvent);
}


//========================================================================================================================================

VOID ConditionVariable() {

    InitializeConditionVariable(&conditionVariable);

}

//========================================== Inter Locked ================================================================================




VOID InterLocked() {

}

//test function
DWORD WINAPI test_function(__in LPVOID lpstr) {
    printf("Parameter in other thread is: %s\n", lpstr);
    printf("Other thread is running!!!\n");
    return 0;
}


//func1
DWORD WINAPI func_even(__in LPVOID lpnum) {
    
    while (gcount < 10) {
        WaitForSingleObject(hMutex, INFINITE);

        if (gcount % 2 == 0)
            printf("gcount - even is: %d\n", gcount++);
        ReleaseMutex(hMutex);
    }

    return 0;
}

//func2
DWORD WINAPI func_odd(__in LPVOID lpnum) {

    while (gcount < 10) {
        WaitForSingleObject(hMutex, INFINITE);

        if (gcount % 2 == 1)
            printf("gcount - odd is: %d\n", gcount++);
        ReleaseMutex(hMutex);
    }
    return 0;
}


DWORD WINAPI func1Event(__in LPVOID lpnum) {

    while (ecount < 10) {
        ResetEvent(hEvent);
        if (ecount % 2 == 0)
            printf("ecount - odd is: %d\n", ecount++);
        SetEvent(hEvent);
    }

    return 0;
}


DWORD WINAPI func2Event(__in LPVOID lpnum) {

    while (ecount < 10) {
        ResetEvent(hEvent);
        if (ecount % 2 == 1)
            printf("ecount - even is: %d\n", ecount++);
        SetEvent(hEvent);
    }

    return 0;
}
