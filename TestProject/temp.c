//
//char* getString(int start, int end, char string[])
//{
//    char* substring = malloc(MAX_CHUNK);
//    int index = 0;
//    
//    for (int i = start; i < end; i++) {
//        substring[index] = string[i];
//        index++;
//    }
//    
//    return substring;
//
//}

//
//VOID GetInput(CHAR str[]) {
//    //int count = 0, count2 = 0;
//    //printf("%s\n", str);
//    //int strLen = strlen(str);
//    //CHAR* result[MAX_CHUNK];
//    ///*ZeroMemory(result, MAX_CHUNK);
//    //if (str[strLen - 1] == '\n')
//    //    str[strLen - 1] = '\0';
//    //for (int i = 0; i < strLen; i++) {
//    //    if (str[i] == ' ' && count == 0) {
//    //        result = getString(0, i, str);
//    //        printf("%s", result);
//    //        count++;
//    //    }
//
//    //}*/
//    //char temp[MAX_CHUNK];
//    //for (int i = 0; i < strLen; i++) {
//    //    temp[count] = str[i];
//    //    count++;
//    //    if (str[i] == ' ') {
//    //        result[count2] = temp;
//    //        count2++;
//    //        ZeroMemory(temp, MAX_CHUNK);
//    //        count = 0;
//    //    }
//    //}
//    //for (int i = 0; i < sizeof(result); i++) {
//    //    printf("%s\n", result[i]);
//    //}
//
//    char delimiter[] = " ,\t\n";
//    char* next = NULL;
//    char* token = NULL;
//    token = strtok_s(str, delimiter, &next);
//
//    while (token != NULL) {
//        printf("%s\n", token);
//        token = strtok_s(NULL, delimiter, &next);
//    }
//    //char* parts[10];
//    //int partcount = 0;
//
//    //parts[partcount++] = str;
//
//    //char* ptr = str;
//    //while (*ptr) { //check if the string is over
//    //    if (*ptr == ' ') {
//    //        *ptr = '\0';
//    //        parts[partcount++] = ptr + 1;
//    //    }
//    //    ptr++;
//    //}
//    //for (int i = 0; i < sizeof(partcount); i++) {
//    //    printf("%s\n", parts[i]);
//    //}
//
//}
//
//void SplitBufferToArray(char* buffer, char* delim, char** Output) {
//
//    int partcount = 0;
//    Output[partcount++] = buffer;
//
//    char* ptr = buffer;
//    while (ptr != 0) { //check if the string is over
//        ptr = strstr(ptr, delim);
//        if (ptr != NULL) {
//            *ptr = '\0';
//            Output[partcount++] = ptr + strlen(delim);
//            ptr = ptr + strlen(delim);
//        }
//
//    }
//    Output[partcount++] = NULL;
//}


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <WinSock2.h>
#include<Windows.h>
#include<Lmcons.h>
#include<time.h>
#include<TlHelp32.h>

#pragma comment(lib, "ws2_32.lib")

void resolve_and_connect(const char* domain) {
    struct hostent* host_info;
    struct sockaddr_in server_addr;
    int socket_fd;

    // Phân giải địa chỉ IP từ domain name
    host_info = gethostbyname(domain);
    if (host_info == NULL) {
        fprintf(stderr, "Lỗi khi phân giải địa chỉ IP\n");
        exit(1);
    }

    // In địa chỉ IP đã phân giải
    printf("Địa chỉ IP của %s: %s\n", domain, inet_ntoa(*((struct in_addr*)host_info->h_addr_list[0])));

    // Tạo socket
    socket_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (socket_fd == -1) {
        perror("Lỗi khi tạo socket");
        exit(1);
    }

    // Thiết lập địa chỉ và cổng của server
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(80);
    memcpy(&server_addr.sin_addr, host_info->h_addr, host_info->h_length);

    // Kết nối đến server
    if (connect(socket_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        perror("Lỗi khi kết nối");
        exit(1);
    }

    printf("Kết nối thành công!\n");

    // Đóng socket sau khi sử dụng
    close(socket_fd);
}

int main() {
    // Gọi hàm và truyền domain name cần phân giải và kết nối
    resolve_and_connect("www.duongb3.com");

    return 0;
}



//FD_ZERO(&activeSocket);
//for (int i = 0; i < 50; i++) {
//    if (agents[i].Socket == 0)
//        break;
//    printf("socket: %d\n", agents[i].Socket);
//    FD_SET(agents[i].Socket, &activeSocket);
//    //closesocket(agents[i].Socket);
//    /*if(i == 2)
//        closesocket(agents[1].Socket);*/
//}
//TIMEVAL timeout;
//timeout.tv_sec = 30;
//timeout.tv_usec = 0;
//int result;
//result = select(0, &activeSocket, &activeSocket, NULL, &timeout);
//if (result == SOCKET_ERROR) {
//    printf("Fail select\n");
//}
//for (int i = 0; i < 50 || agents[i].Socket != 0; i++) {
//    if (FD_ISSET(agents[1].Socket, &activeSocket)) {
//        printf("agent: %d\n", agents[i].Socket);
//    }
//}
