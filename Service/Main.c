#include<stdio.h>
#include<Windows.h>
#include<WinBase.h>
#include<stdlib.h>
#include<TlHelp32.h>
#define SLEEP_TIME 5000

SERVICE_STATUS serviceStatus;
SERVICE_STATUS_HANDLE hStatus;

VOID ServiceMain(int argc, LPSTR argv[]);
VOID ControlHandler(DWORD request);
DWORD RunInjector(int argc, LPSTR argv[]);
DWORD RunDropper(int argc, LPSTR argr[]);

int main(int argc, char** argv) {
	SERVICE_TABLE_ENTRY DispatchTable[] = {
		{"SyaorenService", (LPSERVICE_MAIN_FUNCTION)ServiceMain},
		{NULL, NULL}
	};
	DWORD dwCurrentProcessId = GetCurrentProcessId();
	PROCESSENTRY32 pe32;
	pe32.dwSize = sizeof(PROCESSENTRY32);
	DWORD x = 0;
	HANDLE hFile = CreateFileA("C:\\Users\\Hii\\Desktop\\malicious.txt", GENERIC_WRITE, 0,
					NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	// Tạo một snapshot của tất cả các tiến trình
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnapshot == INVALID_HANDLE_VALUE) {
		WriteFile(hFile, "snapshot", 9, &x, NULL);
		printf("Failed to take snapshot\n");
		return 0;
	}
	// Bắt đầu với tiến trình đầu tiên
	if (Process32First(hSnapshot, &pe32)) {
		do {
			// Nếu tìm thấy tiến trình con, kiểm tra xem nó có phải là tiến trình cha không
			if (pe32.th32ProcessID == dwCurrentProcessId) {
				printf("[+] Parent process id: %d\n", pe32.th32ParentProcessID);
				HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pe32.th32ParentProcessID);
				if (hProcess != NULL) {
					CHAR processName[MAX_PATH];
					DWORD dwProcessNameSz = sizeof(processName) / sizeof(processName[0]);
					if (QueryFullProcessImageNameA(hProcess, 0, processName, &dwProcessNameSz)) {
						LPSTR x = strrchr(processName, '\\');
						x++;
						//WriteFile(hFile, processName, dwProcessNameSz, &x, NULL);
						//CloseHandle(hFile);
						CHAR serviceName[] = "services.exe";
						DWORD dwServiceNameSz = strlen(serviceName);
						if (RtlCompareMemory(x, serviceName, dwServiceNameSz) == dwServiceNameSz) {
							StartServiceCtrlDispatcherA(DispatchTable);
						}
						else {
							printf("[+] Nothing here\n");
						}
						return 0;
					}
					else {
						WriteFile(hFile, "failed", 7, &x, NULL);
						CloseHandle(hFile);
						return 0;
						printf("[-] Failed to get process image name\n");
					}
				}
				else {
					WriteFile(hFile, "process failed", strlen("process failed"), &x, NULL);
					return 0;
					printf("[-] Failed to open parent process. Error code = %d\n", GetLastError());
				}
			}
		} while (Process32Next(hSnapshot, &pe32));
	}
	return 0;
}

DWORD RunInjector(int argc, LPSTR argv[]) {
	HANDLE hFile = CreateFileW(L"C:\\Users\\Sy40r3n\\Desktop\\anotherfile.txt", GENERIC_WRITE, 0, NULL,
		CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	CHAR message[] = "hacking by syaoren";
	DWORD dwMessageLen = strlen(message);
	DWORD x = 0;
	WriteFile(hFile, message, dwMessageLen, &x, NULL);
	CloseHandle(hFile);
	return 1;
}

DWORD RunDropper(int argc, LPSTR argv[]) {
	
	return 1;
}

VOID ServiceMain(int argc, LPSTR argv[]) {
	serviceStatus.dwServiceType = SERVICE_WIN32;
	serviceStatus.dwCurrentState = SERVICE_START_PENDING;
	serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
	serviceStatus.dwWin32ExitCode = 0;
	serviceStatus.dwServiceSpecificExitCode = 0;
	serviceStatus.dwCheckPoint = 0;
	serviceStatus.dwWaitHint = 0;

	hStatus = RegisterServiceCtrlHandlerA("SyaorenService", (LPHANDLER_FUNCTION)ControlHandler);
	RunInjector(argc, argv);
	serviceStatus.dwCurrentState = SERVICE_RUNNING;
	SetServiceStatus(hStatus, &serviceStatus);

	while (serviceStatus.dwCurrentState == SERVICE_RUNNING) {
		Sleep(SLEEP_TIME);
	}
	return;
		
}

VOID ControlHandler(DWORD request) {
	switch (request) {
	case SERVICE_CONTROL_STOP:
		serviceStatus.dwWin32ExitCode = 0;
		serviceStatus.dwCurrentState = SERVICE_STOPPED;
		SetServiceStatus(hStatus, &serviceStatus);
		return;

	case SERVICE_CONTROL_SHUTDOWN:
		serviceStatus.dwWin32ExitCode = 0;
		serviceStatus.dwCurrentState = SERVICE_STOPPED;
		SetServiceStatus(hStatus, &serviceStatus);
		return;

	default:
		break;
	}
	SetServiceStatus(hStatus, &serviceStatus);
	return;
}



